        -:    0:Source:../src/dynarray.c
        -:    0:Graph:.\a-dynarray.gcno
        -:    0:Data:.\a-dynarray.gcda
        -:    0:Runs:3
        -:    1:#include <rmgui/dynarray.h>
        -:    2:#include <rmgui/util.h>
        -:    3:#include <stdlib.h>
        -:    4:#include <assert.h>
        -:    5:
        -:    6:
        -:    7:
function initialize_vec called 3 returned 100% blocks executed 75%
        3:    8:vector initialize_vec(size_t elem_size)
        -:    9:{
       3*:   10:    assert(elem_size != 0 && "VECTOR ERROR, ELEMENT SIZE MUSTN'T BE ZERO");
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
call    2 never executed
        3:   11:    vector dynarray = {.elem_size = elem_size, .capacity = VECTOR_INITIAL_CAPACITY * elem_size,
        -:   12:                        .size = 0};
        -:   13:
        3:   14:    dynarray.data = malloc(dynarray.capacity);
        -:   15:    
        3:   16:    if(UNLIKELY(!dynarray.data))
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
    #####:   17:        dynarray.status = VECTOR_ALLOCATION_ERROR;
        -:   18:    else
        3:   19:        dynarray.status = VECTOR_NO_ERROR;
        -:   20:
        -:   21:
        -:   22:
        3:   23:    return dynarray;
        -:   24:}
        -:   25:
function free_vector called 3 returned 100% blocks executed 100%
        3:   26:void free_vector(vector *vec)
        -:   27:{
        3:   28:    free(vec->data);
        3:   29:    vec->status = VECTOR_FREED;
        -:   30:
        3:   31:}
        -:   32:
        -:   33:/* no overflow protection yet*/
function resize_vector called 100000 returned 100% blocks executed 55%
   100000:   34:int resize_vector(vector *vec, size_t size)
        -:   35:{
        -:   36:    //only realloc when size > capacity
   100000:   37:    if(UNLIKELY(size * vec->elem_size > vec->capacity))
branch  0 taken 1% (fallthrough)
branch  1 taken 100%
        -:   38:    {
        -:   39:        //the usual doubling
       14:   40:        size_t new_cap_elem = (vec->capacity / vec->elem_size) * 2;
        -:   41:        
        -:   42:        //if this rare case happens, run pow2
       14:   43:        if(new_cap_elem < size)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   44:        {
    #####:   45:            new_cap_elem = round_next_pow2(size);
        -:   46:        }
        -:   47:        
       14:   48:        void *tmp = realloc(vec->data, new_cap_elem * vec->elem_size);
       14:   49:        if(!tmp)
branch  0 taken 0% (fallthrough)
branch  1 taken 100%
        -:   50:        {
    #####:   51:            vec->status = VECTOR_ALLOCATION_ERROR;
    #####:   52:            return -1;
        -:   53:        }
       14:   54:        vec->capacity = new_cap_elem * vec->elem_size;
       14:   55:        vec->data = tmp;        
        -:   56:        
       14:   57:        memset((char *)vec->data + vec->size * vec->elem_size, 0, 
       14:   58:                (size - vec->size) * vec->elem_size);
        -:   59:    }
        -:   60:
   100000:   61:    vec->size = size;
        -:   62:
   100000:   63:    return 0;
        -:   64:}
        -:   65:
function insert_vector called 100000 returned 100% blocks executed 82%
   100000:   66:int insert_vector(vector *vec, const void *elements, size_t start, size_t end)
        -:   67:{
   100000:   68:    if(!vec || !elements || end == 0)
branch  0 taken 100% (fallthrough)
branch  1 taken 0%
branch  2 taken 100% (fallthrough)
branch  3 taken 0%
branch  4 taken 0% (fallthrough)
branch  5 taken 100%
    #####:   69:        return 0;
        -:   70:
   100000:   71:    start = start > vec->size ? vec->size : start;
        -:   72:
   100000:   73:    size_t old_size = vec->size;
   100000:   74:    if(resize_vector(vec, vec->size + end))
call    0 returned 100%
branch  1 taken 0% (fallthrough)
branch  2 taken 100%
    #####:   75:        return -1;
        -:   76:
        -:   77:    //memmove to create space if inserted in the middle
   100000:   78:    if(start < old_size)
branch  0 taken 100% (fallthrough)
branch  1 taken 1%
        -:   79:    {
    99999:   80:        memmove((char *) vec->data + (start + end) * vec->elem_size, 
    99999:   81:                (char *) vec->data + start * vec->elem_size,
    99999:   82:                (old_size - start) * vec->elem_size);
        -:   83:    }
        -:   84:
   100000:   85:    memcpy((char *) vec->data + start * vec->elem_size, elements, end * vec->elem_size);
   100000:   86:    return 0;
        -:   87:}
